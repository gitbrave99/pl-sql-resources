--TRIGGERS
    TIPO
        DML: INSERT, UPDATE, DELETE
        DDL: CREATE, DROP...
        DATABASE: LOGON, SHUTDOWN

TIPOS             EVENTOS     FILAS AFECTADAS
- BEFORE          -INSERT       STATEMENT: se dispara una vez en AFTER STATEMENT, BEFORE STATEMENT
- AFTER           -UPDATE       ROW: mas orientados a controlar cada fila
- INSTEAD OF      -DELETE       no permite delete, UPDATE, delete
                                se dispara para determinadas vistas que no son modificables 
                                xq son complejas

--TRIGGER
--Create a new Schema Trigger
CREATE OR REPLACE TRIGGER INS_EMPL
AFTER INSERT ON REGIONS
BEGIN
    INSERT INTO LOG_TB VALUES('INSERCION EN LA TABLE',USER);
END;

--  HACER QUE SOLO EL USUARIO HR PUEDA HACER INSERT A REGIONS
CREATE OR REPLACE TRIGGER TR1_REGION 
BEFORE INSERT ON REGIONS 
BEGIN
    IF USER <> 'HR' THEN
        RAISE_APPLICATION_ERROR(-20000,'Solo HR puede hacer insert en regiones');
    END IF;
END;





--  HACER QUE SOLO EL USUARIO HR PUEDA HACER INSERT,UPDATE, DELETE A REGIONS
CREATE OR REPLACE TRIGGER TR1_REGION 
BEFORE INSERT OR UPDATE DELETE ON REGIONS 
BEGIN
    IF USER <> 'HR' THEN
        RAISE_APPLICATION_ERROR(-20000,'Solo HR puede hacer INSERT, UPDATE, DELETE en regiones');
    END IF;
END;




--  HACER QUE SOLO EL USUARIO HR PUEDA HACER INSERT,UPDATE, DELETE A REGIONS
-- y QUE SOLO SE DISPARE EN ACTUALIZACION CUANDO SE MODIFIQUE EL CAMPO REGION_NAME
-- SI QUEREMOS AGREGAR MAS COLUMNAS COLOCAMOS ,

CREATE OR REPLACE TRIGGER TR1_REGION 
BEFORE INSERT OR UPDATE OF REGION_NAME OR DELETE ON REGIONS 
BEGIN
    IF USER <> 'HR' THEN
        RAISE_APPLICATION_ERROR(-20000,'Solo HR puede hacer INSERT, UPDATE, DELETE en regiones');
    END IF;
END;

UPDATE HR.REGIONS SET REGION_ID = 1040 WHERE REGION_ID = 1000;



------------------------------------------------------------------------
------------------------------------------------------------------------
--CONTROLAR EL TIPO DE EVENTO

CREATE OR REPLACE TRIGGER TR1_REGION 
BEFORE INSERT OR UPDATE OF REGION_NAME OR DELETE ON REGIONS 
BEGIN
    
    IF INSERTING THEN 
        INSERT INTO LOG_TB VALUES('INSERCIÓN',USER);
    END IF;
    IF UPDATING THEN
        INSERT INTO LOG_TB VALUES('ACTUALIZACIÓN',USER);
    END IF;
    IF DELETING THEN
        INSERT INTO LOG_TB VALUES('ALIMINACIÓN',USER);
    END IF;
END;


--CONTROLAR EL TIPO DE EVENTO
-- y las COLUMNAS
CREATE OR REPLACE TRIGGER TR1_REGION 
BEFORE INSERT OR UPDATE OR DELETE ON REGIONS 
BEGIN
    IF INSERTING THEN 
        INSERT INTO LOG_TB VALUES('INSERCIÓN',USER);
    END IF;
    IF UPDATING('REGION_NAME') THEN
        INSERT INTO LOG_TB VALUES('ACTUALIZACIÓN CUANDO DE MODIFIQUE REGION_NAME',USER);
    END IF;
    IF UPDATING('REGION_ID') THEN
        INSERT INTO LOG_TB VALUES('ACTUALIZACIÓN CUANDO DE MODIFIQUE REGION_ID',USER);
    END IF;
    IF DELETING THEN
        INSERT INTO LOG_TB VALUES('ALIMINACIÓN',USER);
    END IF;
    -- IF USER <> 'HR' THEN
    --     RAISE_APPLICATION_ERROR(-20000,'Solo HR puede hacer INSERT, UPDATE, DELETE en regiones');
    -- END IF;
END;

-------------------------------------------------
-------------------------------------------------
TRIGGERS DE TIPO ROW
    Se disparan poor cada fila
    podemos acceder a los datos de esa fila con :old y :new

-- OPERACION          OLD                    NEW
-- INSERT             NULL              VALOR DEL INSERT
-- UPDATE             VALOR ANTERIOR    VALOR NUEVO
-- DELETE             VALOR ANTERIOR    NULL

CREATE OR REPLACE TRIGGER tr1_region
BEFORE INSERT OR UPDATE OR DELETE ON REGIONS
FOR EACH ROW
BEGIN
    IF  INSERTING THEN
        :NEW.REGION_NAME:= UPPER(:NEW.REGION_NAME);
        INSERT INTO LOG_TB VALUES('INSERCION EACH ROW',USER);
    END IF;
    
    IF  UPDATING('REGION_NAME') THEN
        INSERT INTO LOG_TB VALUES('UPDATING FOR EACH ROW, OLD: '||:OLD.REGION_NAME||' NEW: '||:NEW.REGION_NAME,USER);
    END IF;
    
    IF  UPDATING('REGION_ID') THEN
        INSERT INTO LOG_TB VALUES('UPDATING FOR EACH ROW',USER);
    END IF;

    IF  DELETING THEN
        INSERT INTO LOG_TB VALUES('DELETEING EACH ROW',USER);
    END IF;
END;

------------------------------------------------------------------------------------------
--****************************************************************************************
------------------------------------------------------------------------------------------
-- USANDO CLAUSULA WHEN PARA QUE SE HAGAN LAS OPERACIONES SIEMPRE Y CUADNO EL
-- REGION_ID SEA MAYOR QUE 1000

CREATE OR REPLACE TRIGGER tr1_region
BEFORE INSERT OR UPDATE OR DELETE ON REGIONS
FOR EACH ROW
WHEN (NEW.REGION_ID> 1000)
BEGIN
    IF  INSERTING THEN
        :NEW.REGION_NAME:= UPPER(:NEW.REGION_NAME);
        INSERT INTO LOG_TB VALUES('INSERCION EACH ROW',USER);
    END IF;
    
    IF  UPDATING('REGION_NAME') THEN
        INSERT INTO LOG_TB VALUES('UPDATING FOR EACH ROW, OLD: '||:OLD.REGION_NAME||' NEW: '||:NEW.REGION_NAME,USER);
    END IF;
    
    IF  UPDATING('REGION_ID') THEN
        INSERT INTO LOG_TB VALUES('UPDATING FOR EACH ROW',USER);
    END IF;

    IF  DELETING THEN
        INSERT INTO LOG_TB VALUES('DELETEING EACH ROW',USER);
    END IF;
END;

INSERT INTO REGIONS VALUES(19,'REGIONS85');
UPDATE REGIONS SET REGION_NAME='PASO PRUEBA' WHERE REGION_ID = 1060;
delete REGIONS where REGION_ID = 19


--------------
------------
VER DETALLES DE LOS TRIGGERS
    DESC USER_TRIGGERS
    SELECT * FROM USER_TRIGGERS
    select * from user_objects where object_type='TRIGGER'

    -- TRABJAR TRIGGERS EN MODO COMANDO

select * from user_objects where object_type='TRIGGER';

-- COMANDO PARA COMPILAR UN TRIGGER
    ALTER TRIGGER TRIGGER_NAME COMPILE;

-- COMANDO PARA MOSTRAR LOS ERRORES EN PAQUETES, PROCEDIMIENTOS...
    SELECT * FROM USER_ERRORS

-- COMANDO PARA DESABILITAR UN TRIGGER
    ALTER TRIGGER TRIGGER_NAME DISABLE;
-- COMANDO PARA ACTIVAR UN TRIGGER
    ALTER TRIGGER TRIGGER_NAME ENABLE;
-- para ver si esta disable ejecutamos el comando
    SELECT * FROM USER_TRIGGERS


CREATE OR REPLACE PROCEDURE total_empleados
AS
    total NUMBER:=0;
BEGIN
    SELECT COUNT(*) INTO total FROM EMPLOYEES WHERE DEPARTMENT_ID=10000;
    DBMS_OUTPUT.PUT_LINE('TOTAL:'||total);
-- EXCEPTION
--     WHEN NO_DATA_FOUND THEN
--         DBMS_OUTPUT.PUT_LINE('NO HAY DATOS');
END;

BEGIN
    total_empleados;
END;

--- TRIGGER DE TIPO COMPOUND 
-- se creo desde la version 11
-- lo que permite tener distintos tipo de trigger en uno solo
-- EN VEZ DE TENER UN POR CADA EVENTO PODEMOS TENER UNO SOLO QUE MANEJE PARA UNA TABLA

-- ESQUELETO
    DECLARACION
            TIPO
            EVENTO
            ETC
    BEFORE STATEMENT IS
    AFTER STATEMENT IS
    BEFORE EACH ROW IS
    AFTER EACH ROW IS

    -- ESQUELETO DE TRIGGER COMPOUND EN CODIGO
CREATE OR REPLACE TRIGGER TRIGGER_COMPOUND1
FOR DELETE OR INSERT OR UPDATE ON REGIONS -- LOS EVENTOS QUE QUEREMOS
  COMPOUND TRIGGER  -- PALABRAS RESERVADAS PARA QUE SE UN COMPOUND
  
  BEFORE STATEMENT IS BEGIN
    --CODE
  END BEFORE STATEMENT;
  
  AFTER STATEMENT IS BEGIN
    --CODE
  END AFTER STATEMENT;

  BEFORE EACH ROW IS BEGIN
    --CODE
  END BEFORE EACH ROW;

  AFTER EACH ROW IS BEGIN
    --CODE
  END AFTER EACH ROW;

  END TRIGGER_COMPOUND1;
/

-- CREAR TRIGGER CON SUS ELEMENTOS 
-- AL NO TENER LOS INSERTING, UPDATING, DELETING, SE INSERTARN TODOS A LOG_TB
CREATE OR REPLACE TRIGGER TRIGGER_COMPOUND1
FOR DELETE OR INSERT OR UPDATE ON REGIONS -- LOS EVENTOS QUE QUEREMOS
  COMPOUND TRIGGER  -- PALABRAS RESERVADAS PARA QUE SE UN COMPOUND
  
  BEFORE STATEMENT IS BEGIN
    INSERT INTO LOG_TB VALUES('BEFORE STATEMENT ',USER);
  END BEFORE STATEMENT;
  
  AFTER STATEMENT IS BEGIN
    INSERT INTO LOG_TB VALUES('AFTER STATEMENT ',USER);
  END AFTER STATEMENT;

  BEFORE EACH ROW IS BEGIN
    INSERT INTO LOG_TB VALUES('BEFORE EACH ROW STATEMENT ',USER);
  END BEFORE EACH ROW;

  AFTER EACH ROW IS BEGIN
    INSERT INTO LOG_TB VALUES('AFTER EACH ROW STATEMENT ',USER);
  END AFTER EACH ROW;

  END TRIGGER_COMPOUND1;
/
-- PRUEBA DEL TRIGGER5-8
insert into REGIONS values(4000,'test regions compund');
ROLLBACK;


-- CREAR TRIGGER CON SUS ELEMENTOS 
-- CON INSERTING, UPDATING, DELETING
CREATE OR REPLACE TRIGGER TRIGGER_COMPOUND1
FOR DELETE OR INSERT OR UPDATE ON REGIONS -- LOS EVENTOS QUE QUEREMOS
  COMPOUND TRIGGER  -- PALABRAS RESERVADAS PARA QUE SE UN COMPOUND
  
  BEFORE STATEMENT IS BEGIN
    INSERT INTO LOG_TB VALUES('BEFORE STATEMENT ',USER);
  END BEFORE STATEMENT;
  
  AFTER STATEMENT IS BEGIN
    INSERT INTO LOG_TB VALUES('AFTER STATEMENT ',USER);
  END AFTER STATEMENT;

  BEFORE EACH ROW IS BEGIN
    IF INSERTING THEN
        INSERT INTO LOG_TB VALUES('BEFORE EACH ROW INSERT OLD: '||:OLD.REGION_NAME||' NEW:'||:NEW.REGION_NAME,USER);
    END IF;
    IF  UPDATING THEN
        INSERT INTO LOG_TB VALUES('BEFORE  EACH ROW UPDATE OLD: '||:OLD.REGION_NAME||' NEW:'||:NEW.REGION_NAME,USER);
    END IF;
    IF  DELETING THEN
        INSERT INTO LOG_TB VALUES('BEFORE  EACH ROW DELETE OLD: '||:OLD.REGION_NAME||' NEW:'||:NEW.REGION_NAME,USER);
    END IF;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS BEGIN
    IF INSERTING THEN
        INSERT INTO LOG_TB VALUES('AFTER EACH ROW INSERT OLD: '||:OLD.REGION_NAME||' NEW:'||:NEW.REGION_NAME,USER);
    END IF;
    IF  UPDATING THEN
        INSERT INTO LOG_TB VALUES('AFTER EACH ROW UPDATE OLD: '||:OLD.REGION_NAME||' NEW:'||:NEW.REGION_NAME,USER);
    END IF;
    IF  DELETING THEN
        INSERT INTO LOG_TB VALUES('AFTER EACH ROW DELETE OLD: '||:OLD.REGION_NAME||' NEW:'||:NEW.REGION_NAME,USER);
    END IF;
  END AFTER EACH ROW;

END TRIGGER_COMPOUND1;

-- PRUEBA DEL TRIGGER5-8
insert into REGIONS values(4011,'test regions compund dml');
UPDATE REGIONS SET REGION_NAME='TEST RENAMED' WHERE REGION_ID=100
ROLLBACK;

--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
-- TRIGGER DE TIPO DDL
    --tpo control de esquema.  cuando alguien crea una tabla, borra un objeto 
    -- podriamos controlar que nadie borre un TABLE 
-- LO  CREAMOS EN SQLDEVELOPER
-- TRIGGER QUE NO PERMITE ELIMINAR TABLAS7
CREATE OR REPLACE TRIGGER TRIGGER1_DDL 
BEFORE DROP ON HR.SCHEMA 
BEGIN
  RAISE_APPLICATION_ERROR(-20000,'No se puede borrar tablas');
END;








********************************************************************************
********************************************************************************
PRACTICA



--practica

/*
1. Crear un TRIGGER BEFORE DELETE sobre la tabla EMPLOYEES que
    impida borrar un registro si su JOB_ID es algo relacionado con CLERK
*/

CREATE OR REPLACE TRIGGER trg_employee
BEFORE INSERT OR UPDATE OR DELETE ON EMPLOYEES
FOR EACH ROW
BEGIN
    IF :OLD.JOB_ID LIKE '%CLERK%' THEN
        INSERT INTO LOG_TB VALUES('PUDO CLERK',USER);
        DBMS_OUTPUT.PUT_LINE('LIKE');
        RAISE_APPLICATION_ERROR(-20000,'NO SE PUDEN BORRAR LOS EMPLEADO SRELACIONADOS CON CLERK');
    END IF;
    
END;
/

--**********************************************************************
/*
2. Crear una tabla denominada AUDITORIA con las siguientes columnas:
    CREATE TABLE AUDITORIA (
        USUARIO VARCHAR(50),
        FECHA DATE,
        SALARIO_ANTIGUO NUMBER,
        SALARIO_NUEVO NUMBER
    );
*/

---**************************************************************************
/*
3. Crear un TRIGGER BEFORE INSERT de tipo STATEMENT, de forma que
    cada vez que se haga un INSERT en la tabla REGIONS guarde una fila
    en la tabla AUDITORIA con el usuario y la fecha en la que se ha hecho el INSERT
*/

CREATE OR REPLACE TRIGGER TRREG_STATE
    BEFORE INSERT ON REGIONS
BEGIN
        INSERT INTO AUDITORIA(usuario,fecha) VALUES(USER,SYSDATE);
END;
INSERT INTO REGIONS VALUES (20,'Prueba');

--**********************************************************************************
/*
4. Realizar otro trigger BEFORE UPDATE de la columna SALARY de tipo EACH ROW.
    • Si la modificación supone rebajar el salario el TRIGGER debe disparar un
       RAISE_APPLICATION_FAILURE “no se puede bajar un salario”.
    • Si el salario es mayor debemos dejar el salario antiguo y el salario
       nuevo en la tabla AUDITORIA.

*/

CREATE OR REPLACE TRIGGER TRG_EMPLOYEE
    BEFORE UPDATE OF SALARY ON EMPLOYEES
    FOR EACH ROW
BEGIN
    IF :OLD.SALARY > :NEW.SALARY THEN
        RAISE_APPLICATION_ERROR(-20000,'no se puede rebajar un salario');
    END IF;
    INSERT INTO AUDITORIA VALUES(USER,SYSDATE,:OLD.SALARY,:NEW.SALARY);
END;
update EMPLOYEES SET SALARY = 1000 WHERE EMPLOYEE_ID =100

--************************************************************************************
/*
5. Crear un TRIGGER BEFORE INSERT en la tabla DEPARTMENTS que al insertar un departamento 
    compruebe que el código no esté repetido y luego que si el LOCATION_ID es NULL 
    le ponga 1700 y si el MANAGER_ID es NULL le ponga 200
*/

INSERT INTO DEPARTMENTS VALUES(300,'PRUEBA INSERT DEP',NULL,NULL);

CREATE OR REPLACE TRIGGER  TRG_DEPARTMENTS 
    BEFORE INSERT ON DEPARTMENTS
    FOR EACH ROW
DECLARE 
    codigo DEPARTMENTS.DEPARTMENT_ID%TYPE;
    CURSOR allDepts IS SELECT DEPARTMENT_ID FROM DEPARTMENTS;
BEGIN
    OPEN allDepts;
        LOOP
            FETCH allDepts INTO codigo;
            IF codigo = :NEW.DEPARTMENT_ID THEN
                RAISE_APPLICATION_ERROR(-20000,'YA EXISTE DEPARTAMENTO');
            END IF;

            IF :NEW.LOCATION_ID IS NULL THEN
                :NEW.LOCATION_ID:=1700;
            END IF;

            IF :NEW.MANAGER_ID IS NULL THEN
                :NEW.MANAGER_ID:=200;
            END IF;
            EXIT WHEN allDepts%NOTFOUND;
        END LOOP;
    CLOSE allDepts;
EXCEPTION 
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Ya existe un departamento');
        INSERT INTO LOG_TB VALUES('Ya existe un departamento',USER);
END;



